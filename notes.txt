--------------------------------------------------------------------Основы работы с терминалом Linux-----------------------------------------------------------------------
Сокращения:
Т = терминал

uname - узнать какая ОС установлена
uname -a (all) - информация про ОС более подробно

lscpu (list cpu) - информация о процессоре

clear - очистить экран терминала

echo - команда для вывода текста
echo "Hello world" - Т выведет "Hello world"

Нахоядсь в домашней дирректории мы можем указать команду "ls", которая выведет список дочерних дирректорий в строчку или "ls -l" для вывода дочерних дирректорий в столбик
"ls -la -R" - показывает все файлы на диске

Для того чтобы вывести набор возможных команд используют команду "man -k ключевое_слово_для_поиска"
    man - это не мужик, а сокращение от manual (учебное пособие)
    -k - сокращение от keywords
Например, "man -k time" выведет все команды которые содержат в себе слово time (в том числе и в описаниии команды)

Когда мы уже знаем название команды, которую хотим использовать и нам нужно почитать про команду подробнее, мы пишем команду "man название_команды". После выполнения
команды Т отобразить подробную информацию о команде. Чтобы искать что-то в этой информации по ключевым словам, нужно использовать "/", чтобы выйти "q"

Чтобы получить короткое описание команды можно использовать команду "whatis название_команды"
Чтобы узнать путь, по которому находится наша команда, мы используем похожую команду "whereis название_команды" или "locate название_команды"

ps - показывает текущие запущенные процессы

Ctrl + C - прервать выполнение команды полностью
Ctrl + Z - приостановить выполнение команды
fg (foreground - передний план) - запустить выполнение команды после приостановки 



------------------------------------------------------------------------Навигация по дирректориям---------------------------------------------------------------------------

В Linux в отличие от Windows нет различных дисков в памяти компьютера, а есть только лишь корневой каталог "/". Внутри этой дирректории (главного корня) находятся различные
дочерние дирректории (папки). Например, дирректория home содержит в себе пользователей, а дирректория media содержит папки, которые как бы являются подразеделнием памяти 
компьютера на диски, наподобие Windows

cd - изменить дирректорию
ls -l (long) - показать лист дирректорий внутри текущей в формате "long"
ls -la - показать лист дирректорий внутри текущей даже с скрытыми файлами
. - текущая дирректория
.. - выйти из текущей дирректории
pwd (print working directory) - вывести текущую дирректорию 

Чтобы после команды cd не писать весь путь в случае когда мы просто хотим провалиться внутрь дочерней дирректории мы можем использовать запись вида:
"cd название_дирректории/"
и тогда нам не придется писать весь путь для погружения в эту дочернюю дирректорию, т.е. мы избежим
"cd /home/egor/название_дирректории"

Чтобы вернуться в домашнюю дирректорию пользователя достаточно просто написать "cd". При этом когда мы находимся внутри дирректории пользователя в терминале всегда перед 
строкой ввода команд будет отображаться символ "~". Также можно написать "cd ~" и мы все равно вернемся к домашней дирректории. Таким образом "cd ~" заменяет нам запись
"cd /home/egor" 
 


-----------------------------------------------------------------------------CRUD файлов------------------------------------------------------------------------------------

Внутри Т Linux есть встренный "viewer" которые мы вызывали, когда вызывали команду "man название_команды". Внутри этого viewer мы можем листать полученный текст с помощью
pageUp и pageDown, а также Enter. Этот viewer используется для чтения файлов, т.е. вывода текста, содержащегося внутри.

Для чтения существует несколько команд:
cat название_файла - выведет весь текст просто в терминале (неудобно т.к. файлы могут быть большими)
more название_файла - вывеет весь текст просто в Т, но его можно листать с помощью Enter
less название_файла - выведет весь текст с помощью viewer 

touch название_файла - создаст файл с названием "название_файла"
Применение данной комнады к существующему файлу не пересоздаст его, а просто перезапишет время его последнего изменения

mkdir (make directory) название_дирректории - создаст директорию с названием "название_директории"

cp (copy) название_файла путь_для_копирования - копирует файл из текущей дирректории "название_файла" в папку заданную с помощью "путь_для_копирования"
Также с помощью cp можно копировать дирректории по тому же принципу.

rm (remove) название_файла - удалит файл с названием "название_файла"


Символ * означает любой набор символов внутри названий файлов или дирректорий (такой функционал называется глоббинг "globbing")
    ls * - выведет все файлы в каталоге
    ls *.txt - выведет все файлы с расширением .txt
    ls file*.txt - выведет все файлы начинающиеся на "file" и заканчивающиеся ".txt"
Похожим является символ ? , ведь он также означает любой символ, но только один.

Поэтому для того, чтобы копировать файлы:
    firstTextFile.txt
    secondTextFile.txt
    thirdTextFile.txt
с помощью одной команды, нам необходимо использовать символ * следующим образом:
cp *TextFile.txt путь_для_копирования

Соотвтетственно, удалять несколько файлов в текущей дирректории можно по тому же принципу:
rm *TextFile.txt

А если мы хотим удалить файлы в другой дирректории то сначала пишем название дирректории, а затем название файла.

Чтобы скопировать дирректории (рекурсивно, т.е. с их содержанием) нужно использовать ту же команду "cp", но с приписыванием "-R" (recursive)
cp название_дирректории -r путь_для_копирования
Для удаления дирректории также нужно указывать параметр -r, т.к. мы не можем удалить папку оставив в ней содержимое.
rm -r название_дирректории

mv название_файла новое_название - переименует файл в файл с названием "новое_название"
С помощью этой команды файлы можно делать невидимыми для "ls -l" (скрытыми), просто задавая им новое название начинающуееся с точки
    mv firstTextFile.txt .firstTextFile.txt

Однако стоит заметить, что команда "mv" не просто переименовывает файл, она его перемещает в указанное место с новым названием. Т.е. вырезает из текущей дирректории и 
добавляет с новым указанным нами названием, по указанному нами пути.
Соотвтетственно, мы можем переносить файлы с помощью команды "mv" следующим образом:
    mv .secretFile.txt ~/Desktop/
или
    mv .secretFile.txt ~/Desktop/новое_название_файла
если его при перемещении необходимо переименовать



------------------------------------------------------------------------Работа с дирректориями------------------------------------------------------------------------------

Запись вида "mkdir dir4/dir5" не создает сначала dir4, а затем внутри неё dir5, а ищет в текущей дирректории dir4 и если такая есть создает в ней dir5. Т.е. грубо говоря,
запись "mkdir название_дирректории" правильнее называть "mkdir путь_для_создания/название_дирректории". То же поведение и при создании файлов.

Для того чтобы сразу создать вложенные дирректории в предыдущей записи "mkdir dir4/dir5" нужно добавить параметр -p (parrent)
    mkdir -p dir4/dir5

ВАЖНО:
ls -R dir3 - показывает все рекурсивно лежащие внутри дирректории
ls -r dir3 - показывает вложенные в дирректорию файлы и каталоги в обрабтном алфавитном порядке, но не затрагивает вложенность

Для удаления дирректорий используется команда "rmdir" (remove directory)

Соотвтетственно, что копировать и удалять дирректории рекурсивно (т.е. с их содержимым) нам нужно использовать параметр -R 
Исходя из этого, можно заметить, что команда 
    rm -R /
удалит всю операционную систему, поэтому ЭТУ КОМАНДУ ИСПОЛЬЗОВАТЬ НЕ НАДО!!!

Эта команда удалит все файлы кроме тех которые мы можем использовать как администратор. Чтобы выполнить удаление вообще всего и выполнить это удаление как бы от лица 
администратора перед командой надо добавить запись "sudo" (super user do) (сделать что-то от лица главного пользователя)



------------------------------------------------------------------------Создание ярлыка (линк)------------------------------------------------------------------------------

Для того чтобы создать ссылку на какую-то дирректорию или файл, необходимо воспользоваться командой:
    ln -s путь_на_файл_или_дирректорию название_ссылки
ln (link)
-s (symbolic)

Если использовать ln без параметра -s, то можно создать "идеальный" дубликат файла на который мы хотели создать ссылку. Такой файл отличается от первоначального лишь
названием и в случае изменения хотя бы одного из них, второй меняется тоже (как объекты в JS и переменные содержащие ссылки на них)



---------------------------------------------------------------------Команды: find, cut, sort, wc---------------------------------------------------------------------------

Такие команды как whereis и locate ищут только системные файлы. Для того чтобы найти какой-то файл рекурсивно (в глубину) в текущей дирректории используют команду find.
Данная команда ищет файл по различным параметрам, но чаще всего по названию.
    find -name "firstTextFile.txt"
Для того чтобы найти файл внутри конкретной (но не текущей дирректории) перед "-name" и названием файла нужно добавить "название_дирректории"
    find /home -name "firstTextFile.txt"
Важно заметить, что название берётся в кавычки.

wc название_файла - выводит количество строк, количество слов, количество символов и название файла.
Если мы хотим вывести только количество строк, необходимо использовать параметр -l 
    wc -l firstTextFile.txt
Если хотим вывести только количество слов, параметр -w 
    wc -w firstTextFile.txt

sort название_файла - сортирует содержимое файла по алфавиту (если текст) или посимвольно (если цифры) (т.е. сначала те которые начинаются на 1 затем на 2 и т.д.) и 
возвращает в порядке возрастания.
    sort names.txt
Чтобы отсортировать файл содержащий числа не по символам, а по значению этих чисел, нужно в команду добавить параметр "-n"
    sort -n numbers.txt
При этом важно понимать, что для сортировки, значения должны быть каждое на новой строке, т.к. между собой сравниваюстя значения строк.

cut - команда наподобие метода массивов split(), внутри JavaScript. Команда разделяет каждую строку файла на отдельные части по определенному делимитру -d (delimiter)
Т.е. если каждая строка представляет собой данные об одной сущности разделенные запятой, то нашим делимитром станет ",". Если нам нужно получить второе поле каждой строки,
например, это поле - возраст, то мы используем параметр -f (field) и далее задаем номер поля. Полный синтаксис команды выглядит так:
    cut -d "," -f 2 название_файла
Данная команда выведет для каждой строки (сущности) возраст из файла "название_файла"

Для того чтобы выполнять команды последовательно, существует специальный символ "|" (pipe)
Синтаксис вида:
    команда1 | вкоманда2
выполнит команду1 и у результата выполнения команды1 выполнит команду2

Соотвтетственно, для того чтобы сразу после split'а данных из файла отсортировать их можно использовать следующий синтаксис:
    cut -d ">" -f 4 thirdTextFile.txt | sort
