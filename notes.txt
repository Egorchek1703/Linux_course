--------------------------------------------------------------------Основы работы с терминалом Linux-----------------------------------------------------------------------
Сокращения:
Т = терминал

uname - узнать какая ОС установлена
uname -a (all) - информация про ОС более подробно

lscpu (list cpu) - информация о процессоре

clear - очистить экран терминала

echo - команда для вывода текста
echo "Hello world" - Т выведет "Hello world"

Нахоядсь в домашней дирректории мы можем указать команду "ls", которая выведет список дочерних дирректорий в строчку или "ls -l" для вывода дочерних дирректорий в столбик
"ls -la -R" - показывает все файлы на диске

Для того чтобы вывести набор возможных команд используют команду "man -k ключевое_слово_для_поиска"
    man - это не мужик, а сокращение от manual (учебное пособие)
    -k - сокращение от keywords
Например, "man -k time" выведет все команды которые содержат в себе слово time (в том числе и в описаниии команды)

Когда мы уже знаем название команды, которую хотим использовать и нам нужно почитать про команду подробнее, мы пишем команду "man название_команды". После выполнения
команды Т отобразить подробную информацию о команде. Чтобы искать что-то в этой информации по ключевым словам, нужно использовать "/", чтобы выйти "q"

Чтобы получить короткое описание команды можно использовать команду "whatis название_команды"
Чтобы узнать путь, по которому находится наша команда, мы используем похожую команду "whereis название_команды" или "locate название_команды"

ps - показывает текущие запущенные процессы

Ctrl + C - прервать выполнение команды полностью
Ctrl + Z - приостановить выполнение команды
fg (foreground - передний план) - запустить выполнение команды после приостановки 



------------------------------------------------------------------------Навигация по дирректориям---------------------------------------------------------------------------

В Linux в отличие от Windows нет различных дисков в памяти компьютера, а есть только лишь корневой каталог "/". Внутри этой дирректории (главного корня) находятся различные
дочерние дирректории (папки). Например, дирректория home содержит в себе пользователей, а дирректория media содержит папки, которые как бы являются подразеделнием памяти 
компьютера на диски, наподобие Windows

cd - изменить дирректорию
ls -l (long) - показать лист дирректорий внутри текущей в формате "long"
ls -la - показать лист дирректорий внутри текущей даже с скрытыми файлами
. - текущая дирректория
.. - выйти из текущей дирректории
pwd (print working directory) - вывести текущую дирректорию 

Чтобы после команды cd не писать весь путь в случае когда мы просто хотим провалиться внутрь дочерней дирректории мы можем использовать запись вида:
"cd название_дирректории/"
и тогда нам не придется писать весь путь для погружения в эту дочернюю дирректорию, т.е. мы избежим
"cd /home/egor/название_дирректории"

Чтобы вернуться в домашнюю дирректорию пользователя достаточно просто написать "cd". При этом когда мы находимся внутри дирректории пользователя в терминале всегда перед 
строкой ввода команд будет отображаться символ "~". Также можно написать "cd ~" и мы все равно вернемся к домашней дирректории. Таким образом "cd ~" заменяет нам запись
"cd /home/egor" 
 


-----------------------------------------------------------------------------CRUD файлов------------------------------------------------------------------------------------

Внутри Т Linux есть встренный "viewer" которые мы вызывали, когда вызывали команду "man название_команды". Внутри этого viewer мы можем листать полученный текст с помощью
pageUp и pageDown, а также Enter. Этот viewer используется для чтения файлов, т.е. вывода текста, содержащегося внутри.

Для чтения существует несколько команд:
cat название_файла - выведет весь текст просто в терминале (неудобно т.к. файлы могут быть большими)
more название_файла - вывеет весь текст просто в Т, но его можно листать с помощью Enter
less название_файла - выведет весь текст с помощью viewer 

touch название_файла - создаст файл с названием "название_файла"
Применение данной комнады к существующему файлу не пересоздаст его, а просто перезапишет время его последнего изменения

mkdir (make directory) название_дирректории - создаст директорию с названием "название_директории"

cp (copy) название_файла путь_для_копирования - копирует файл из текущей дирректории "название_файла" в папку заданную с помощью "путь_для_копирования"
Также с помощью cp можно копировать дирректории по тому же принципу.

rm (remove) название_файла - удалит файл с названием "название_файла"


Символ * означает любой набор символов внутри названий файлов или дирректорий (такой функционал называется глоббинг "globbing")
    ls * - выведет все файлы в каталоге
    ls *.txt - выведет все файлы с расширением .txt
    ls file*.txt - выведет все файлы начинающиеся на "file" и заканчивающиеся ".txt"
Похожим является символ ? , ведь он также означает любой символ, но только один.

Поэтому для того, чтобы копировать файлы:
    firstTextFile.txt
    secondTextFile.txt
    thirdTextFile.txt
с помощью одной команды, нам необходимо использовать символ * следующим образом:
cp *TextFile.txt путь_для_копирования

Соотвтетственно, удалять несколько файлов в текущей дирректории можно по тому же принципу:
rm *TextFile.txt

А если мы хотим удалить файлы в другой дирректории то сначала пишем название дирректории, а затем название файла.

Чтобы скопировать дирректории (рекурсивно, т.е. с их содержанием) нужно использовать ту же команду "cp", но с приписыванием "-R" (recursive)
cp название_дирректории -r путь_для_копирования
Для удаления дирректории также нужно указывать параметр -r, т.к. мы не можем удалить папку оставив в ней содержимое.
rm -r название_дирректории

mv название_файла новое_название - переименует файл в файл с названием "новое_название"
С помощью этой команды файлы можно делать невидимыми для "ls -l" (скрытыми), просто задавая им новое название начинающуееся с точки
    mv firstTextFile.txt .firstTextFile.txt

Однако стоит заметить, что команда "mv" не просто переименовывает файл, она его перемещает в указанное место с новым названием. Т.е. вырезает из текущей дирректории и 
добавляет с новым указанным нами названием, по указанному нами пути.
Соотвтетственно, мы можем переносить файлы с помощью команды "mv" следующим образом:
    mv .secretFile.txt ~/Desktop/
или
    mv .secretFile.txt ~/Desktop/новое_название_файла
если его при перемещении необходимо переименовать



------------------------------------------------------------------------Работа с дирректориями------------------------------------------------------------------------------

Запись вида "mkdir dir4/dir5" не создает сначала dir4, а затем внутри неё dir5, а ищет в текущей дирректории dir4 и если такая есть создает в ней dir5. Т.е. грубо говоря,
запись "mkdir название_дирректории" правильнее называть "mkdir путь_для_создания/название_дирректории". То же поведение и при создании файлов.

Для того чтобы сразу создать вложенные дирректории в предыдущей записи "mkdir dir4/dir5" нужно добавить параметр -p (parrent)
    mkdir -p dir4/dir5

ВАЖНО:
ls -R dir3 - показывает все рекурсивно лежащие внутри дирректории
ls -r dir3 - показывает вложенные в дирректорию файлы и каталоги в обрабтном алфавитном порядке, но не затрагивает вложенность

Для удаления дирректорий используется команда "rmdir" (remove directory)

Соотвтетственно, что копировать и удалять дирректории рекурсивно (т.е. с их содержимым) нам нужно использовать параметр -R 
Исходя из этого, можно заметить, что команда 
    rm -R /
удалит всю операционную систему, поэтому ЭТУ КОМАНДУ ИСПОЛЬЗОВАТЬ НЕ НАДО!!!

Эта команда удалит все файлы кроме тех которые мы можем использовать как администратор. Чтобы выполнить удаление вообще всего и выполнить это удаление как бы от лица 
администратора перед командой надо добавить запись "sudo" (super user do) (сделать что-то от лица главного пользователя)



------------------------------------------------------------------------Создание ярлыка (линк)------------------------------------------------------------------------------

Для того чтобы создать ссылку на какую-то дирректорию или файл, необходимо воспользоваться командой:
    ln -s путь_на_файл_или_дирректорию название_ссылки
ln (link)
-s (symbolic)

Если использовать ln без параметра -s, то можно создать "идеальный" дубликат файла на который мы хотели создать ссылку. Такой файл отличается от первоначального лишь
названием и в случае изменения хотя бы одного из них, второй меняется тоже (как объекты в JS и переменные содержащие ссылки на них)



---------------------------------------------------------------------Команды: find, cut, sort, wc---------------------------------------------------------------------------

Такие команды как whereis и locate ищут только системные файлы. Для того чтобы найти какой-то файл рекурсивно (в глубину) в текущей дирректории используют команду find.
Данная команда ищет файл по различным параметрам, но чаще всего по названию.
    find -name "firstTextFile.txt"
Для того чтобы найти файл внутри конкретной (но не текущей дирректории) перед "-name" и названием файла нужно добавить "название_дирректории"
    find /home -name "firstTextFile.txt"
Важно заметить, что название берётся в кавычки.

wc название_файла - выводит количество строк, количество слов, количество символов и название файла.
Если мы хотим вывести только количество строк, необходимо использовать параметр -l 
    wc -l firstTextFile.txt
Если хотим вывести только количество слов, параметр -w 
    wc -w firstTextFile.txt

sort название_файла - сортирует содержимое файла по алфавиту (если текст) или посимвольно (если цифры) (т.е. сначала те которые начинаются на 1 затем на 2 и т.д.) и 
возвращает в порядке возрастания.
    sort names.txt
Чтобы отсортировать файл содержащий числа не по символам, а по значению этих чисел, нужно в команду добавить параметр "-n"
    sort -n numbers.txt
При этом важно понимать, что для сортировки, значения должны быть каждое на новой строке, т.к. между собой сравниваюстя значения строк.

cut - команда наподобие метода массивов split(), внутри JavaScript. Команда разделяет каждую строку файла на отдельные части по определенному делимитру -d (delimiter)
Т.е. если каждая строка представляет собой данные об одной сущности разделенные запятой, то нашим делимитром станет ",". Если нам нужно получить второе поле каждой строки,
например, это поле - возраст, то мы используем параметр -f (field) и далее задаем номер поля. Полный синтаксис команды выглядит так:
    cut -d "," -f 2 название_файла
Данная команда выведет для каждой строки (сущности) возраст из файла "название_файла"

Для того чтобы выполнять команды последовательно, существует специальный символ "|" (pipe)
Синтаксис вида:
    команда1 | вкоманда2
выполнит команду1 и у результата выполнения команды1 выполнит команду2

Соотвтетственно, для того чтобы сразу после split'а данных из файла отсортировать их можно использовать следующий синтаксис:
    cut -d ">" -f 4 thirdTextFile.txt | sort



-------------------------------------------------------------------Команда grep и регулярные выражения----------------------------------------------------------------------

grep выражение_для_поиска название_директории (где ищем) - команда ищет соответствие внутри файлов "выражению_для_поиска" и если находит, выводит название файла и строчку,
в которой было обнаружено соответствие. grep (global regular expression print) - глобальная печать регулярного выражения.

Т.е. команда:
    grep linux ./*
Найдет ВСЕ (*) файлы и дирректории с соответствующими строками внутри них, которые содержат данное выражение "linux". Если бы мы не использовали символ *, то команда 
нашла бы первое совпадение и вывела только его. Важно отметить, что поиск не осуществляется рекурсивно по умолчанию. Для этого надо использовать либо параметр -r. 
Важно, что использование символа * также означает поиск вообще всего, что содержит данное регулярное выражение (в том числе и директории), а использование параметра -r 
ищет только файлы.

В данном примере выражение "linux" является регулярным выражением, а значит мы можем добавлять к нему различные параметры (как в JavaScript), например, такие как:
-i - игнорирование регистра (т.е. мы ищем не просто именно "linux", а еще и другие совпадения регулярного выражения игнорируя отличия в регистре символов)
-r - выполняет рекурсивный поиск по всем файлам и подкаталогам, лежащим внутри дирректории в которой выполняем поиск

Составление регулярного выражения:
Для обозначения возможных значений для определенного символа используются квадратные скобки []
Для того чтобы обозначить регулярное выражение перед ним нужно указать -E (expression) и само выражение заключить в кавычки

A-Z - любая заглавная буква от A до Z
a-z - любая строчная буква от a до z

Запись вида [A-Z][a-z] ищет два символа первый должен быть заглавной буквой в диапазоне от A до Z, а второй в том же диапазоне только строчной. Чтобы найти любые 
соответствия для любого количества символов можно использовать выражение [A-Za-z]*, где * означает любое количество символов удовлетворяющее условию A-Za-z

Для экранирования различных символов используется символ "\" после которого указывается сам символ, который необходимо экранировать.

Специальные символы которые нужно экранировать внутри команды
    . (точка) - Любой одиночный символ
    * (звездочка) - Ноль или более предыдущих символов
    + (плюс) - Один или более предыдущих символов
    ? (вопросительный знак) - Ноль или один предыдущий символ
    ^ (каретка) - Начало строки
    $ (доллар) - Конец строки
    [] (квадратные скобки) - Символьный класс
    () (круглые скобки) - Группировка
    {} (фигурные скобки) - Квантификаторы
    | (вертикальная черта) - Логическое ИЛИ
    \ (обратный слэш) - Сам по себе является символом экранирования

Например, у нас есть файл пользователей, где данные представлены для каждой сущности на отдельной строке и хранятся в формате "имя_пользователя - электронная_почта". Нам
необходимо вывести всех почты у которых домен имеет вид "имя_ящика@system.net". Для этого необходимо использовать регулярное выражение вида:
    "[A-Za-z\.\-\_]*@system.net"
и искать его с помощью команды:
    grep -rE "[A-Za-z\.\-\_]*@system.net" путь_к_директории_для_поиска

Для того, чтобы в регулярное выражение добавить опциональность, нужно использовать символ "|", который означает "логическое или" (ранее использовали его для 
последовательного выполнения команд). Т.е. если мы также ищем домен формата "имя_ящика@mailservice.org", нам нужно использовать команду:
    grep -rE "[A-Za-z\.\-\_]*@system.net|[A-Za-z\.\-\_]*@mailservice.org" путь_к_директории_для_поиска
Для того чтобы позже посчитать количество таких записей можно выполнить последовательно команду wc с помощью
    | wc

Важно отметить, что логическое "или" (|) не обрамляется пробелами

Также важно отметить, что динамическое создание строк осуществляется не как в JavaScript с помощью символа $ и фигурных скобок, а используются круглые скобки для 
обозначения динамического выражения внутри шаблонной строки. 

Чтобы манипулировать датой и временем и настраивать пользовательский способ вывода существуют форматные спецификаторы:
    %Y: Год в четырехзначном формате (например, 2024).
    %y: Год в двузначном формате (например, 24 для 2024 года).
    %m: Месяц в двузначном формате (01 для января, 12 для декабря).
    %d: День месяца в двузначном формате (01-31).
    %H: Часы в 24-часовом формате (00-23).
    %I: Часы в 12-часовом формате (01-12).
    %M: Минуты в двузначном формате (00-59).
    %S: Секунды в двузначном формате (00-59).
    %p: Для AM/PM в 12-часовом формате (AM или PM).
    %A: Полное наименование дня недели (например, Sunday).
    %a: Сокращенное наименование дня недели (например, Sun).
    %B: Полное наименование месяца (например, January).
    %b или %h: Сокращенное наименование месяца (например, Jan).
    %c: Полная дата и время (например, Sun May 18 16:25:30 2024).
    %x: Полная дата (например, 05/18/24 для 18 мая 2024 года).
    %X: Полное время (например, 16:25:30).
Для того чтобы просто получить дату нужно использовать команду date, но в таком случае мы получим данные в формате:
    "ДЕНЬ_НЕДЕЛИ МЕСЯЦ ЧИСЛО время_в_формате_ЧАСЫ_МИНУТЫ_СЕКУНДЫ AM/PM ЧАСОВОЙ_ПОЯС Год"
Чтобы настроить формат вывода с помощью отмеченных ранее спецификаторов нужно после команды дописать символ + и затем в кавычках указать данные спецификаторы, в том 
порядке, в котором их необходимо выводить.



------------------------------------------------------------------------------Редактор vi-----------------------------------------------------------------------------------

Редактор vi - это текстовый редактор, которым можно пользоваться внутри терминала Linux. Чтобы открыть редактор достаточно просто выполнить команду "vi". Чтобы закрыть 
редактор нужно сначала нажать "Esc", а затем дважды сочетание клавиш "Shift + Z".

Чтобы открыть определенный файл и редактировать его в vi, нужно выполнить команду 
    vi путь_к_файлу

У редакторы vi есть ряд особенностей. Главная из них - это наличие двух режимов взаимодействия с редактором. Первый режим после открытия редактора (по умолчанию) - это 
режим Command Mode, в котором мы можем выполнять команды, например, сохранять изменения, удалять строки, закрывать редактор и т.д. Второй режим - это режим вставки Insert
Mode, в котором мы можем редактировать сам текст и передвигаться по нему с помощью курсора. Для того чтобы активировать режим вставки нужно нажать на клавишу "i"
Для навигации доступны стрелки клавиатуры или кнопки H, J, K, L.
H - влево
J - вниз
K - вверх
L - вправо

Чтобы обратно вернуться в командый режим после редактирования текста, необходимо нажать "Esc".

Для того чтобы выполнять сохранение, выход и другие операции в vi необходимо внутри Command Mode активировать командную строку. Для этого необходимо написать двоеточие ":"
Основные команды:
    :w - сохранить изменения
    :q - выйти из редактора
    :wq - сохранить и выйти (или альтернатива :x)
    :q! - выйти без сохранений

Внутри режима Command Mode также можно редактировать текст с помощью ряда команд:
    x - удалить символ под курсором
    dd - удалить строку на которой находится курсор
    u - отменить последнее действие
    r - замена символа под курсором (после команды требуется ввести новый символ)
    R - переход в режим замены (переключение на перезапись текста)
    e - перескачить на конец слова
    b - перескачить на начало слова
    / - начать искать совпадения в файле 



-----------------------------------------------------------------Перенаправление вывода/ввода - /dev/null-------------------------------------------------------------------

В Linux существует возможность сохранять результаты выполнения определенных команд внутри различных файлов. Например, у нас есть файл содержащий какие-то данные о 
пользователях, и мы хотим вырезать с каждой строки данного файла имя пользователя, а затем все эти имена отсортировать и поместить результат внутри другого файла, например,
с именем users_sorted_names.txt

Для того чтобы вложить результат выполнения команды в какой-то файл достаточно после команды указать:
    > название_файла_для_хранения_результата

Т.е. в нашем примере такой функционал можно реализовать с помощью команды:
    cut -d ">" -f 1 users_data.txt | sort > users_sorted_names.txt

Символ ">" перезатирает все содержимое файла и записывает результат последнего выполнения команды. Для того чтобы добавлять в результирующий файл, а не перезаписывать его 
постоянно нужно использовать символ ">>"
    cut -d ">" -f 4 users_data.txt | sort >> users_sorted_names.txt

Важно отметить, что при выполнении команды содержащей ">", Linux в первую очередь создает файл или перезатирает. То есть сохранить, например, отсортированные данные из 
файла внутри этого же файла не получится
    sort name.txt > names.txt
Файл names.txt будет пустой, т.к. перед выполнением команды sort мы перезатерли файл и его содержимое теперь пустое, а значит нечего сортировать

Иногда когда мы выполняем какие-то команды мы получаем "плохие" ответы, яркие пример тому - "permission denied". Если мы не хотим получать такие ответы, а хотим чтобы 
отображались только "хорошие", нам необходимо скрыть данные ответы. Для обращения к ним используется не просто символ ">", а символы "2>". Соответственно, заменив > на 2>
мы можем выкинуть ошибки в какой-то файл, например, errors.txt. Но если нам не нужно сохранять эти ошибки впринципе, то мы можем закинуть их в директорию "пустого девайса"
Внутри корневого каталога есть директория dev (devises) внутри которой находится директория null. Попадая туда, данные автоматически стираются.
    grep -rE "egor" / 2> /dev/null
Т.е. перекинуть все ошибки при поиске файлов содержащих egor внутри корневого каталога в /dev/null 
Теперь в терминале будут выведены только "хорошие ответы"
При этом чтобы сохранить ошибки отдельно от хороших ответов, нужно использовать и символ ">" + название_файла_с+хорошими_результатами, и символы "2>" + название_файла_с_ошибками 
Чтобы сохранить и поток плохих ответов и поток хороших нужно не разделять их на > и 2>, и помещать в один файл, т.к. сохраниться что-то ведь файл перезатирается, а нужно 
использовать символы "&>", который сохраняет оба потока



--------------------------------------------------------------------Запуск процессов в фоновом режиме-----------------------------------------------------------------------

* nohup
Для того чтобы выполнять некоторые процессы после выхода из системы и завершения сеанса в Linux существует ряд команд, позволяющих сделать это. Одним из них является 
процесс nohup (no hung up - не вешай трубку). Для того чтобы запустить процесс в фоновом режиме с помощью этой команды необходимо перед самой командой добавить ключевое
слово nohup, затем команда самого процесса и затем символ амперсанд "&". Результат выполнения процесса будет сохранен в директории запуска команды в файле под названием
"nohup.out". Т.е. команда:
    hohup команда_процесса &
будет выполняться даже в случае выхода из системы и сохранит результаты выполнения в файле nohup.out в директории выполнения скрипта. Для того чтобы остановить процесс 
нужно использовать команду kill/killall + название_выполняемого_скрипта
Важно отметить, что "выход из системы" и "завершение сеанса" - это не равно перезагрузке виртуальной машины или физического компьютера. Эти термины означают выход из 
терминала, например, с использованием "exit"

* screen
Также существует специальная утилита screen, которая позволяет запускать несколько терминалов в одном окне и переключаться между ними, в том числе и выходить из сессии,
не завершая процесс ее работы. Предварительно ее необходимо установить с помощью:
    sudo apt install screen
Тут "apt" означает "Advanced Package Tool" (продвинутый пакетный инструмент) (как npm в NodeJS) и соответственно, когда мы выполняем установку или другие операции с 
пакетами (приложениями) мы должны обращаться к пакетному менеджеру, а затем уже задавать команду для выполнения.

Теперь чтобы запустить утилиту, необходимо ввести ее название "screen" в терминале для запуска. Автоматически мы попадаем в сессию_0.

Ctrl + A, C - создать новую сессию
Ctrl + A, 5 - для переключения между сессиями (где 5 - номер сессии)
Ctrl + D - выйти из текущей сессии
Ctrl + A + D - отключиться от screen (или Ctrl + D, находясь в нулевой сессии)
Чтобы подключиться к закрытой сессии screen используется команда "screen -r", однако если уже есть подключенный пользователь к данной сессии эта команда не позволит туда
зайти. 
Для того чтобы подключиться к сессии когда их несколько нужно также ввести "screen -r" и после появитсья табилца с количеством сессий и их id. Теперь чтобы подключиться
к конкретной сессии нужно ввести команду "screen -r id_сессии"
Чтобы подключиться к сессии с несколькими пользователями нужно использовать команду "screen -rx id_сессии" (у сессий имеющих подключенных пользователей статус "Attached",
а у сессий без подключенных пользователей "Detached")

screen -ls - также как и "screen -r" позволяет просматривать все текущие сессии

* tmux
Помимо вышеприведенных утилит, существует ещё одна универсальная и более производительная утилита "tmux". Данная утилита очень похожа на screen, но имеет ряд преимуществ
над screen. Её также необходимо предварительно установить с помощью:
    sudo apt install tmux

tmux - запустить утилиту (попадаем в нулевую сессию)
tmux new-session -s название_сессии - созданиие сессии
Ctrl + B, D - отключиться от сессии
tmux list-session
tmux attach-session -t название_сессии - подключение к существующей сессии
tmux kill-session -t название_сессии - удаление сессии



-----------------------------------------------------------Права доступа и владения файлами и директориями------------------------------------------------------------------

Для того чтобы отобразить права доступа к определенному файлу или директории необходимо использовать команду:
    ls -l название_файла_или_директории
Для того чтобы отобразить все файлы с правами доступа к ним внутри определенной директории достаточно вызвать уже известную нам команду 
    ls -la 
В ответ на данные команды Т возвращает запись вида: "-rw-r--r-- 1 user group 1234 May 23 10:00 filename". Данное сообщение расшифровывается следующим образом:

    -
    первый символ означает тип элемента: для файла "-", для директории "d", для ссылки (ярлыка) "l"

Далее идут группы из трёх символов с шаблоном "rwx" (read, write, execute), т.е. права на чтение, запись и выполнение (файла) или возможность заходить в директорию и 
работать с её содержимым. Там где право ограничено для каждой группы вместо буквы ставится "-". Первая группа - права владельца, вторая группа - права группы, третья 
группа - права всех остальных пользователей

    rw-
    группа из трёх символом, означающая права владельца (чтение и запись) (без выполнения файла)

    r--
    группа из трёх символов, означающая права группы (только чтение)

    r--
    группа из трёх символов, означающая права остальных пользователей (только чтение)

Далее следует число, которое означает количество жестких ссылок на файл или количество вложенных директорий для директории. Затем следует запись "user group", которая
показывает к какому пользователю и какой группе пользователей существует права из первой и второй группы символов (rwx). После этого следует размер файла в байтах (число),
затем дата и время последнего изменения и наконец, название самого файла.

* Переназначение прав и владельцев файлов и директорий

Для того чтобы изменить владельца файла (пользователя), необходимо задать с помощью sudo права суперюзера на выполнение команды, а затем использовать команду 
chown (change owner) имя_нового_владельца имя_файла_или_директории. Т.е. команда:
    sudo chown petya file.txt
поменяет владельца файла, например, с "egor" на "petya" для файла file.txt
Для изменения группы нужно использовать команду chgrp (change group) в таком же шаблоне:
    sudo chgrp Programmers file.txt

Для того чтобы переназначить права существует два способа: буквенный и числовой. Разберем изначально буквенный. Каждая из трех групп символов (вида rwx) имеет 
соответствующую букву для её обозначения. Первая группа - пользователь = u (user), вторая группа - группа = g (group), третья группа - все остальные = o (other). 
Эти названия существуют для того, чтобы можно было задать определенные права, обратившись к конкретной группе прав. После обращения к группе для присваивания права 
(r, w или x) необходимо использовать "+", а для удаления "-". Изменения прав осуществляется с помощью команды chmod
    chmod u+x,o+w file.txt
Данная команда добавляет для пользователя право выполнять файл, а для всех остальных добавляет право записывать в него что-либо.
Если нужно задать какое-то право всем группа, то вместо "ugo" можно использовать "a" (all) и знак "=" (но не "+" или "-").
    chmod a=r file.txt
Данная команда присваивает всем группам право чтения.

Теперь рассмотрим подход числовой. Он отличается тем, что нельзя, как в буквенном подходе добавить только какой-то конкретной группе определенное право. Этот подход 
перезаписывает сразу права для всех групп. В числовом подходе используется присваивание каждой букве (r, w, x) соотвтествуюащя цифра. А именно:
    r = 4
    w = 2
    x = 1
Соответственно, чтобы задать определенный набор прав нужно просто сложить данные числа и написать для каждой группы пользователей соответствующее число, а именно:
    chmod 764 file.txt
Данная команда означает, что пользователю (u) присваивается 7, т.е. "rwx". 
    r(4) + w(2) + x(1) = 7
Группе присваивается "rw-"
    r(4) + w(2) + -(0) = 6
Остальным пользователям присваивается только "r--"
    r(4) + -(0) + -(0) = 4

Несмотря на отсутствие прав "rwx" на определенный файл внутри директории, в которой у нас есть права "x", можно удалять файлы, к которым мы не имеем прав доступа. Т.е.
в директории с "drwxrwxrwx" мы можем удалять файлы с набором прав "----------". Это связано с тем, что "x" для директории позволяет взаимодейтсвовать с её содержимым. 
Чтобы возможность взаимодействия была, но удаление мы не могли осуществлять существует специальное право "t", которое также можно добавить директории с помощью:
    sudo chmod o+t название_директории
После этой команды мы не сможем удалять файлы к которым не имеем доступа, но сохраним возможность взаимодействия с ними. Такое поведение называется "StickyBit"

Соответственно, для того чтобы убрать данное право, мы должны использовать команду:
    sudo chmod o-t название_директории

Или также можем использовать числовой способ присваивания и удаления данного правила. Первая цифра указания набора правил является StickyBit, т.е.:
    sudo chmod 1777 название_директории - включение t
    sudo chmod 0777 название_директории - выключение t

Важно отметить, что для изменения набора прав доступа для директорий необходимо использовать права суперпользователя, т.е. sudo
