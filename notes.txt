--------------------------------------------------------------------Основы работы с терминалом Linux-----------------------------------------------------------------------
Сокращения:
Т = терминал

uname - узнать какая ОС установлена
uname -a (all) - информация про ОС более подробно

lscpu (list cpu) - информация о процессоре

clear - очистить экран терминала

echo - команда для вывода текста
echo "Hello world" - Т выведет "Hello world"

Нахоядсь в домашней дирректории мы можем указать команду "ls", которая выведет список дочерних дирректорий в строчку или "ls -l" для вывода дочерних дирректорий в столбик
"ls -la -R" - показывает все файлы на диске

Для того чтобы вывести набор возможных команд используют команду "man -k ключевое_слово_для_поиска"
    man - это не мужик, а сокращение от manual (учебное пособие)
    -k - сокращение от keywords
Например, "man -k time" выведет все команды которые содержат в себе слово time (в том числе и в описаниии команды)

Когда мы уже знаем название команды, которую хотим использовать и нам нужно почитать про команду подробнее, мы пишем команду "man название_команды". После выполнения
команды Т отобразить подробную информацию о команде. Чтобы искать что-то в этой информации по ключевым словам, нужно использовать "/", чтобы выйти "q"

Чтобы получить короткое описание команды можно использовать команду "whatis название_команды"
Чтобы узнать путь, по которому находится наша команда, мы используем похожую команду "whereis название_команды" или "locate название_команды"

ps - показывает текущие запущенные процессы

Ctrl + C - прервать выполнение команды полностью
Ctrl + Z - приостановить выполнение команды
fg (foreground - передний план) - запустить выполнение команды после приостановки 



------------------------------------------------------------------------Навигация по дирректориям---------------------------------------------------------------------------

В Linux в отличие от Windows нет различных дисков в памяти компьютера, а есть только лишь корневой каталог "/". Внутри этой дирректории (главного корня) находятся различные
дочерние дирректории (папки). Например, дирректория home содержит в себе пользователей, а дирректория media содержит папки, которые как бы являются подразеделнием памяти 
компьютера на диски, наподобие Windows

cd - изменить дирректорию
ls -l (long) - показать лист дирректорий внутри текущей в формате "long"
ls -la - показать лист дирректорий внутри текущей даже с скрытыми файлами
. - текущая дирректория
.. - выйти из текущей дирректории
pwd (print working directory) - вывести текущую дирректорию 

Чтобы после команды cd не писать весь путь в случае когда мы просто хотим провалиться внутрь дочерней дирректории мы можем использовать запись вида:
"cd название_дирректории/"
и тогда нам не придется писать весь путь для погружения в эту дочернюю дирректорию, т.е. мы избежим
"cd /home/egor/название_дирректории"

Чтобы вернуться в домашнюю дирректорию пользователя достаточно просто написать "cd". При этом когда мы находимся внутри дирректории пользователя в терминале всегда перед 
строкой ввода команд будет отображаться символ "~". Также можно написать "cd ~" и мы все равно вернемся к домашней дирректории. Таким образом "cd ~" заменяет нам запись
"cd /home/egor" 
 


-----------------------------------------------------------------------------CRUD файлов------------------------------------------------------------------------------------

Внутри Т Linux есть встренный "viewer" которые мы вызывали, когда вызывали команду "man название_команды". Внутри этого viewer мы можем листать полученный текст с помощью
pageUp и pageDown, а также Enter. Этот viewer используется для чтения файлов, т.е. вывода текста, содержащегося внутри.

Для чтения существует несколько команд:
cat название_файла - выведет весь текст просто в терминале (неудобно т.к. файлы могут быть большими)
more название_файла - вывеет весь текст просто в Т, но его можно листать с помощью Enter
less название_файла - выведет весь текст с помощью viewer 

touch название_файла - создаст файл с названием "название_файла"
Применение данной комнады к существующему файлу не пересоздаст его, а просто перезапишет время его последнего изменения

mkdir (make directory) название_дирректории - создаст директорию с названием "название_директории"

cp (copy) название_файла путь_для_копирования - копирует файл из текущей дирректории "название_файла" в папку заданную с помощью "путь_для_копирования"
Также с помощью cp можно копировать дирректории по тому же принципу.

rm (remove) название_файла - удалит файл с названием "название_файла"


Символ * означает любой набор символов внутри названий файлов или дирректорий (такой функционал называется глоббинг "globbing")
    ls * - выведет все файлы в каталоге
    ls *.txt - выведет все файлы с расширением .txt
    ls file*.txt - выведет все файлы начинающиеся на "file" и заканчивающиеся ".txt"
Похожим является символ ? , ведь он также означает любой символ, но только один.

Поэтому для того, чтобы копировать файлы:
    firstTextFile.txt
    secondTextFile.txt
    thirdTextFile.txt
с помощью одной команды, нам необходимо использовать символ * следующим образом:
cp *TextFile.txt путь_для_копирования

Соотвтетственно, удалять несколько файлов в текущей дирректории можно по тому же принципу:
rm *TextFile.txt

А если мы хотим удалить файлы в другой дирректории то сначала пишем название дирректории, а затем название файла.

Чтобы скопировать дирректории (рекурсивно, т.е. с их содержанием) нужно использовать ту же команду "cp", но с приписыванием "-R" (recursive)
cp название_дирректории -r путь_для_копирования
Для удаления дирректории также нужно указывать параметр -r, т.к. мы не можем удалить папку оставив в ней содержимое.
rm -r название_дирректории

mv название_файла новое_название - переименует файл в файл с названием "новое_название"
С помощью этой команды файлы можно делать невидимыми для "ls -l" (скрытыми), просто задавая им новое название начинающуееся с точки
    mv firstTextFile.txt .firstTextFile.txt

Однако стоит заметить, что команда "mv" не просто переименовывает файл, она его перемещает в указанное место с новым названием. Т.е. вырезает из текущей дирректории и 
добавляет с новым указанным нами названием, по указанному нами пути.
Соотвтетственно, мы можем переносить файлы с помощью команды "mv" следующим образом:
    mv .secretFile.txt ~/Desktop/
или
    mv .secretFile.txt ~/Desktop/новое_название_файла
если его при перемещении необходимо переименовать



------------------------------------------------------------------------Работа с дирректориями------------------------------------------------------------------------------

Запись вида "mkdir dir4/dir5" не создает сначала dir4, а затем внутри неё dir5, а ищет в текущей дирректории dir4 и если такая есть создает в ней dir5. Т.е. грубо говоря,
запись "mkdir название_дирректории" правильнее называть "mkdir путь_для_создания/название_дирректории". То же поведение и при создании файлов.

Для того чтобы сразу создать вложенные дирректории в предыдущей записи "mkdir dir4/dir5" нужно добавить параметр -p (parrent)
    mkdir -p dir4/dir5

ВАЖНО:
ls -R dir3 - показывает все рекурсивно лежащие внутри дирректории
ls -r dir3 - показывает вложенные в дирректорию файлы и каталоги в обрабтном алфавитном порядке, но не затрагивает вложенность

Для удаления дирректорий используется команда "rmdir" (remove directory)

Соотвтетственно, что копировать и удалять дирректории рекурсивно (т.е. с их содержимым) нам нужно использовать параметр -R 
Исходя из этого, можно заметить, что команда 
    rm -R /
удалит всю операционную систему, поэтому ЭТУ КОМАНДУ ИСПОЛЬЗОВАТЬ НЕ НАДО!!!

Эта команда удалит все файлы кроме тех которые мы можем использовать как администратор. Чтобы выполнить удаление вообще всего и выполнить это удаление как бы от лица 
администратора перед командой надо добавить запись "sudo" (super user do) (сделать что-то от лица главного пользователя)



------------------------------------------------------------------------Создание ярлыка (линк)------------------------------------------------------------------------------

Для того чтобы создать ссылку на какую-то дирректорию или файл, необходимо воспользоваться командой:
    ln -s путь_на_файл_или_дирректорию название_ссылки
ln (link)
-s (symbolic)

Если использовать ln без параметра -s, то можно создать "идеальный" дубликат файла на который мы хотели создать ссылку. Такой файл отличается от первоначального лишь
названием и в случае изменения хотя бы одного из них, второй меняется тоже (как объекты в JS и переменные содержащие ссылки на них)



---------------------------------------------------------------------Команды: find, cut, sort, wc---------------------------------------------------------------------------

Такие команды как whereis и locate ищут только системные файлы. Для того чтобы найти какой-то файл рекурсивно (в глубину) в текущей дирректории используют команду find.
Данная команда ищет файл по различным параметрам, но чаще всего по названию.
    find -name "firstTextFile.txt"
Для того чтобы найти файл внутри конкретной (но не текущей дирректории) перед "-name" и названием файла нужно добавить "название_дирректории"
    find /home -name "firstTextFile.txt"
Важно заметить, что название берётся в кавычки.

wc название_файла - выводит количество строк, количество слов, количество символов и название файла.
Если мы хотим вывести только количество строк, необходимо использовать параметр -l 
    wc -l firstTextFile.txt
Если хотим вывести только количество слов, параметр -w 
    wc -w firstTextFile.txt

sort название_файла - сортирует содержимое файла по алфавиту (если текст) или посимвольно (если цифры) (т.е. сначала те которые начинаются на 1 затем на 2 и т.д.) и 
возвращает в порядке возрастания.
    sort names.txt
Чтобы отсортировать файл содержащий числа не по символам, а по значению этих чисел, нужно в команду добавить параметр "-n"
    sort -n numbers.txt
При этом важно понимать, что для сортировки, значения должны быть каждое на новой строке, т.к. между собой сравниваюстя значения строк.

cut - команда наподобие метода массивов split(), внутри JavaScript. Команда разделяет каждую строку файла на отдельные части по определенному делимитру -d (delimiter)
Т.е. если каждая строка представляет собой данные об одной сущности разделенные запятой, то нашим делимитром станет ",". Если нам нужно получить второе поле каждой строки,
например, это поле - возраст, то мы используем параметр -f (field) и далее задаем номер поля. Полный синтаксис команды выглядит так:
    cut -d "," -f 2 название_файла
Данная команда выведет для каждой строки (сущности) возраст из файла "название_файла"

Для того чтобы выполнять команды последовательно, существует специальный символ "|" (pipe)
Синтаксис вида:
    команда1 | вкоманда2
выполнит команду1 и у результата выполнения команды1 выполнит команду2

Соотвтетственно, для того чтобы сразу после split'а данных из файла отсортировать их можно использовать следующий синтаксис:
    cut -d ">" -f 4 thirdTextFile.txt | sort



-------------------------------------------------------------------Команда grep и регулярные выражения----------------------------------------------------------------------

grep выражение_для_поиска название_директории (где ищем) - команда ищет соответствие внутри файлов "выражению_для_поиска" и если находит, выводит название файла и строчку,
в которой было обнаружено соответствие. grep (global regular expression print) - глобальная печать регулярного выражения.

Т.е. команда:
    grep linux ./*
Найдет ВСЕ (*) файлы и дирректории с соответствующими строками внутри них, которые содержат данное выражение "linux". Если бы мы не использовали символ *, то команда 
нашла бы первое совпадение и вывела только его. Важно отметить, что поиск не осуществляется рекурсивно по умолчанию. Для этого надо использовать либо параметр -r. 
Важно, что использование символа * также означает поиск вообще всего, что содержит данное регулярное выражение (в том числе и директории), а использование параметра -r 
ищет только файлы.

В данном примере выражение "linux" является регулярным выражением, а значит мы можем добавлять к нему различные параметры (как в JavaScript), например, такие как:
-i - игнорирование регистра (т.е. мы ищем не просто именно "linux", а еще и другие совпадения регулярного выражения игнорируя отличия в регистре символов)
-r - выполняет рекурсивный поиск по всем файлам и подкаталогам, лежащим внутри дирректории в которой выполняем поиск

Составление регулярного выражения:
Для обозначения возможных значений для определенного символа используются квадратные скобки []
Для того чтобы обозначить регулярное выражение перед ним нужно указать -E (expression) и само выражение заключить в кавычки

A-Z - любая заглавная буква от A до Z
a-z - любая строчная буква от a до z

Запись вида [A-Z][a-z] ищет два символа первый должен быть заглавной буквой в диапазоне от A до Z, а второй в том же диапазоне только строчной. Чтобы найти любые 
соответствия для любого количества символов можно использовать выражение [A-Za-z]*, где * означает любое количество символов удовлетворяющее условию A-Za-z

Для экранирования различных символов используется символ "\" после которого указывается сам символ, который необходимо экранировать.

Специальные символы которые нужно экранировать внутри команды
    . (точка) - Любой одиночный символ
    * (звездочка) - Ноль или более предыдущих символов
    + (плюс) - Один или более предыдущих символов
    ? (вопросительный знак) - Ноль или один предыдущий символ
    ^ (каретка) - Начало строки
    $ (доллар) - Конец строки
    [] (квадратные скобки) - Символьный класс
    () (круглые скобки) - Группировка
    {} (фигурные скобки) - Квантификаторы
    | (вертикальная черта) - Логическое ИЛИ
    \ (обратный слэш) - Сам по себе является символом экранирования

Например, у нас есть файл пользователей, где данные представлены для каждой сущности на отдельной строке и хранятся в формате "имя_пользователя - электронная_почта". Нам
необходимо вывести всех почты у которых домен имеет вид "имя_ящика@system.net". Для этого необходимо использовать регулярное выражение вида:
    "[A-Za-z\.\-\_]*@system.net"
и искать его с помощью команды:
    grep -rE "[A-Za-z\.\-\_]*@system.net" путь_к_директории_для_поиска

Для того, чтобы в регулярное выражение добавить опциональность, нужно использовать символ "|", который означает "логическое или" (ранее использовали его для 
последовательного выполнения команд). Т.е. если мы также ищем домен формата "имя_ящика@mailservice.org", нам нужно использовать команду:
    grep -rE "[A-Za-z\.\-\_]*@system.net|[A-Za-z\.\-\_]*@mailservice.org" путь_к_директории_для_поиска
Для того чтобы позже посчитать количество таких записей можно выполнить последовательно команду wc с помощью
    | wc

Важно отметить, что логическое "или" (|) не обрамляется пробелами

Также важно отметить, что динамическое создание строк осуществляется не как в JavaScript с помощью символа $ и фигурных скобок, а используются круглые скобки для 
обозначения динамического выражения внутри шаблонной строки. 

Чтобы манипулировать датой и временем и настраивать пользовательский способ вывода существуют форматные спецификаторы:
    %Y: Год в четырехзначном формате (например, 2024).
    %y: Год в двузначном формате (например, 24 для 2024 года).
    %m: Месяц в двузначном формате (01 для января, 12 для декабря).
    %d: День месяца в двузначном формате (01-31).
    %H: Часы в 24-часовом формате (00-23).
    %I: Часы в 12-часовом формате (01-12).
    %M: Минуты в двузначном формате (00-59).
    %S: Секунды в двузначном формате (00-59).
    %p: Для AM/PM в 12-часовом формате (AM или PM).
    %A: Полное наименование дня недели (например, Sunday).
    %a: Сокращенное наименование дня недели (например, Sun).
    %B: Полное наименование месяца (например, January).
    %b или %h: Сокращенное наименование месяца (например, Jan).
    %c: Полная дата и время (например, Sun May 18 16:25:30 2024).
    %x: Полная дата (например, 05/18/24 для 18 мая 2024 года).
    %X: Полное время (например, 16:25:30).
Для того чтобы просто получить дату нужно использовать команду date, но в таком случае мы получим данные в формате:
    "ДЕНЬ_НЕДЕЛИ МЕСЯЦ ЧИСЛО время_в_формате_ЧАСЫ_МИНУТЫ_СЕКУНДЫ AM/PM ЧАСОВОЙ_ПОЯС Год"
Чтобы настроить формат вывода с помощью отмеченных ранее спецификаторов нужно после команды дописать символ + и затем в кавычках указать данные спецификаторы, в том 
порядке, в котором их необходимо выводить.



------------------------------------------------------------------------------Редактор vi-----------------------------------------------------------------------------------

Редактор vi - это текстовый редактор, которым можно пользоваться внутри терминала Linux. Чтобы открыть редактор достаточно просто выполнить команду "vi". Чтобы закрыть 
редактор нужно сначала нажать "Esc", а затем дважды сочетание клавиш "Shift + Z".

Чтобы открыть определенный файл и редактировать его в vi, нужно выполнить команду 
    vi путь_к_файлу

У редакторы vi есть ряд особенностей. Главная из них - это наличие двух режимов взаимодействия с редактором. Первый режим после открытия редактора (по умолчанию) - это 
режим Command Mode, в котором мы можем выполнять команды, например, сохранять изменения, удалять строки, закрывать редактор и т.д. Второй режим - это режим вставки Insert
Mode, в котором мы можем редактировать сам текст и передвигаться по нему с помощью курсора. Для того чтобы активировать режим вставки нужно нажать на клавишу "i"
Для навигации доступны стрелки клавиатуры или кнопки H, J, K, L.
H - влево
J - вниз
K - вверх
L - вправо

Чтобы обратно вернуться в командый режим после редактирования текста, необходимо нажать "Esc".

Для того чтобы выполнять сохранение, выход и другие операции в vi необходимо внутри Command Mode активировать командную строку. Для этого необходимо написать двоеточие ":"
Основные команды:
    :w - сохранить изменения
    :q - выйти из редактора
    :wq - сохранить и выйти (или альтернатива :x)
    :q! - выйти без сохранений

Внутри режима Command Mode также можно редактировать текст с помощью ряда команд:
    x - удалить символ под курсором
    dd - удалить строку на которой находится курсор
    u - отменить последнее действие
    r - замена символа под курсором (после команды требуется ввести новый символ)
    R - переход в режим замены (переключение на перезапись текста)
    e - перескачить на конец слова
    b - перескачить на начало слова
    / - начать искать совпадения в файле 



-----------------------------------------------------------------Перенаправление вывода/ввода - /dev/null-------------------------------------------------------------------

В Linux существует возможность сохранять результаты выполнения определенных команд внутри различных файлов. Например, у нас есть файл содержащий какие-то данные о 
пользователях, и мы хотим вырезать с каждой строки данного файла имя пользователя, а затем все эти имена отсортировать и поместить результат внутри другого файла, например,
с именем users_sorted_names.txt

Для того чтобы вложить результат выполнения команды в какой-то файл достаточно после команды указать:
    > название_файла_для_хранения_результата

Т.е. в нашем примере такой функционал можно реализовать с помощью команды:
    cut -d ">" -f 1 users_data.txt | sort > users_sorted_names.txt

Символ ">" перезатирает все содержимое файла и записывает результат последнего выполнения команды. Для того чтобы добавлять в результирующий файл, а не перезаписывать его 
постоянно нужно использовать символ ">>"
    cut -d ">" -f 4 users_data.txt | sort >> users_sorted_names.txt

Важно отметить, что при выполнении команды содержащей ">", Linux в первую очередь создает файл или перезатирает. То есть сохранить, например, отсортированные данные из 
файла внутри этого же файла не получится
    sort name.txt > names.txt
Файл names.txt будет пустой, т.к. перед выполнением команды sort мы перезатерли файл и его содержимое теперь пустое, а значит нечего сортировать

Иногда когда мы выполняем какие-то команды мы получаем "плохие" ответы, яркие пример тому - "permission denied". Если мы не хотим получать такие ответы, а хотим чтобы 
отображались только "хорошие", нам необходимо скрыть данные ответы. Для обращения к ним используется не просто символ ">", а символы "2>". Соответственно, заменив > на 2>
мы можем выкинуть ошибки в какой-то файл, например, errors.txt. Но если нам не нужно сохранять эти ошибки впринципе, то мы можем закинуть их в директорию "пустого девайса"
Внутри корневого каталога есть директория dev (devises) внутри которой находится директория null. Попадая туда, данные автоматически стираются.
    grep -rE "egor" / 2> /dev/null
Т.е. перекинуть все ошибки при поиске файлов содержащих egor внутри корневого каталога в /dev/null 
Теперь в терминале будут выведены только "хорошие ответы"
При этом чтобы сохранить ошибки отдельно от хороших ответов, нужно использовать и символ ">" + название_файла_с+хорошими_результатами, и символы "2>" + название_файла_с_ошибками 
Чтобы сохранить и поток плохих ответов и поток хороших нужно не разделять их на > и 2>, и помещать в один файл, т.к. сохраниться что-то ведь файл перезатирается, а нужно 
использовать символы "&>", который сохраняет оба потока